#!/usr/bin/env python3
import requests
import time
import queue
import threading
import sys
import test
import telnetlib
import collections
from datetime import datetime, timedelta

from veighty_machinery.exploit import exploit as veighty_machinery
from treasury.exploit import exploit as treasury

class Challenge:
    def __init__(self, name, port, solver):
        self.name = name
        self.port = port
        self.solver = solver

    def solve(self, team, flag_ids):
        return self.solver(f'fd66:666:{team}::2', self.port)
    
THREADS = 20
TICK = 60 * 3
TEAMS_URL = 'https://2021.faustctf.net/competition/teams.json'
SUBMISSION_ADDR = 'submission.faustctf.net'
SUBMISSION_PORT = 666
MY_TEAM = 488
START_TIME = datetime(2021, 6, 12, 13, 0)

CHALLENGES = [
    Challenge('veighty-machinery', 7777, veighty_machinery),
    Challenge('treasury', 6789, treasury),
]

failure_counts = collections.Counter()

class Job:
    def __init__(self, team, challenge, teams):
        self.team = team
        self.challenge = challenge
        self.flag_ids = teams
        for attr in ['flag_ids', challenge.name, str(team)]:
            self.flag_ids = self.flag_ids.get(attr, {})
        if len(self.flag_ids) == 0:
            self.flag_ids = None

    def solve(self):
        if failure_counts[str(self.team) + self.challenge.name] > 2:
            return False
        try:
            flags = self.challenge.solve(self.team, self.flag_ids)
        except:
            print(f'team: {self.team}, challenge: {self.challenge.name} => Server is unavailable')
            failure_counts[str(self.team) + self.challenge.name] += 1
            return False
        if len(flags) == 0:
            print(f'team: {self.team}, challenge: {self.challenge.name} => Not solved')
            failure_counts[str(self.team) + self.challenge.name] += 1
            return False

        failure_counts[str(self.team) + self.challenge.name] = 0
        self.flags = flags
        return True

    def submit(self):
        with telnetlib.Telnet(SUBMISSION_ADDR, SUBMISSION_PORT) as tn:
            tn.read_until(b'One flag per line please!\n')
            for flag in self.flags:
                tn.write(flag.encode() + b'\n')
                response = tn.read_until(b'\n')[:-1]
            print(f'team: {self.team}, challenge: {self.challenge.name} => {self.flags[0]} ({response.decode()})')

def fetch_teams():
    return requests.get(TEAMS_URL).json()

if len(sys.argv) > 1 and sys.argv[1] == 'test':
    teams = fetch_teams()
    for challenge in CHALLENGES:
        job = Job(MY_TEAM, challenge, teams)
        if job.solve():
            print(f'challenge: {challenge.name} => {job.flags[0]}')
    exit(0)

jobs = queue.Queue()

def execute_job():
    while True:
        job = jobs.get()
        if job.solve():
            job.submit()

for _ in range(THREADS):
    threading.Thread(target=execute_job, daemon=True).start()

while True:
    r = (datetime.now() - START_TIME).seconds // TICK
    print(f'Round: {r}')
    teams = fetch_teams()
    for challenge in CHALLENGES:
        for team in teams['teams']:
            if team != MY_TEAM and failure_counts[str(team) + challenge.name] < 3:
                jobs.put(Job(team, challenge, teams))
    diff = (START_TIME + timedelta(seconds=(r+1) * TICK + 1)) - datetime.now()
    time.sleep(diff.seconds)
